\documentclass[10pt, a4]{article}
\usepackage{geometry}
\usepackage{savetrees}
\usepackage{lineno}
\usepackage{natbib}

\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}

\usepackage{graphicx}
\usepackage[linesnumbered, ruled]{algorithm2e}
\linespread{1.3}

\usepackage{titling}
\title{Agemo: an open-source library for Laplace transformed coalescence time distributions.}
\author{Gertjan Bsschop \thanks{g.bisschop@sms.ed.ac.uk} \\ Institute of Evolutionary Biology, University of Edinburgh, EH9 3FL Edinburgh, Scotland}
\date{}

%%%
\pretitle{\begin{flushright}\LARGE} % makes document title flush right
\posttitle{\end{flushright}}
\preauthor{\begin{flushright}\large} % makes author flush right
\postauthor{\end{flushright}}
\predate{\begin{flushright}\large} % makes date title flush right
\postdate{\end{flushright}}

\begin{document}
\maketitle

\section*{Abstract}
\texttt{agemo} is an open-source tool with a python API that allows users to generate the Laplace transform of the coalescence time distribution of a sample with a given demographic history. In addition, \texttt{agemo} provides ways to efficiently query that distribution, by using the fact that its generating function can be represented most simply as a directed graph with all possible ancestral states of the sample as nodes. Past implementations have not made full use of this, relying on computer algebra systems instead of graph traversal to process these recursive expressions.
\texttt{agemo} can be used to compute the probabilities of the joint site frequency spectrum for blocks of a given size, under models of isolation and migration. Calculating these probabilities requires repeated differentiation of the generating function which suffers from an explosion in the number of terms when implemented naively. Using a closed-form expression for the coefficients of a series expansion of the equations associated with each edge of the graph, we can efficiently propagate these coefficients through the graph avoiding redundant operations.

\vspace{1cm} 
\linenumbers

\section{Introduction}
%starting point: the coalescent:

The coalescent \citep{Kingman1982, Hudson1983, Tajima1983} is the stochastic process modeling the ancestry of a random sample. The theory was derived with the ability to efficiently simulate sequence data in mind \citep{Hudson1983}. For the case of a single panmictic population and without recombination, drawing $n-1$ independent, exponentially distributed waiting times suffices to describe the genealogical tree underlying sequence data. The elegance of this theory lies in its simplicity and in population genetics it has come to serve as the basis of tractable mathematical descriptions as well as the elaborate simulators \citep{Baumdicker2021}.

The framework has proven to be highly extendable, and soon after its introduction the theory was applied to partially isolated populations, the structured coalescent \citep{Takahata1988, Notohara1990, Barton1995}. Laplace transform as instrument to get to the transition probabilities from the rate matrix of a continuous-time Markov chain \citep{Takahata1988, Griffiths1991, Wilkinson-herbots1998}. But as noted by \citet{Wilkinson-herbots1998} the Laplace transforms of the distributions of coalescence times are also interesting in their own right. The Laplace transform has a clear probabilistic interpretation: it is the probability that the event associated with the transformed random variable happens before the occurrence of some catastrophe with an exponentially distributed waiting time \citep{Rade1972}. In a coalescent context, the catastrophe could for example be the occurrence of a mutation along one of the branches in the genealogy. On top of that, the transform has the neat property that the sum of two independent random variables is equal to the product of the respective Laplace transforms. This means that one can readily write down the Laplace transformed distribution of the sum of all inter-event times, or the time to the most recent common ancestor (\textit{tmrca}), associated with any particular sequence of coalescence events \citep{Lohse2011}. This framework, often referred to as the generating function (GF), has been used to develop likelihood-based inference methods both for IM-type demographic histories as well as hard sweeps \citep{Lohse2011, Bunnefeld2015, Lohse2016, Bisschop2021}. Rather than integrating over all ... by getting out the probabilities for seeing .... mutations (bSFS). Still requires repeated differentiation (both depending on the number of observed mutations, and the number of branch types that are being distinguished). 
Fact that this is the complete distribution, not expectation (or ... summary) has its drawbacks, many of which have been discussed and attempts have been made to alleviate some of them. However, one aspect left unused: correspondence between the recursive formulation of the Laplace transform and the coalescent state space graph.

Heree we lay out how the key algorithms that have enabled us to efficiently calculate the bSFS by using the correspondence between the recursive formulation of the Laplace transform and the coalescent state space graph.
because main usage so far getting out bSFS focused on doing this efficiently (requires higher order multivariate derivative taking), making this approach efficient. But in the mean time setting up a general open-source infrastructure, that allows the framework to be extended to ...

Even though possible to get out probability of seeing particular topologies, marginal distribution of coalescence times (no longer in Laplace transform) \citep{Bisschop2021}, actual parameter inference of the associated models has been done by means of getting out the probability distribution of blockwise configurations of completely linked mutations (bSFS). The advantages and potential caveats of this approach have been discussed in great lengths already \citep{Lohhse2011, Lohse2016, Bisschop2021}. Approach positives (), obviously also negatives. 
not open-source, but more importantly not efficient.

because main usage so far getting out bSFS focused on doing this efficiently (requires higher order multivariate derivative taking), making this approach efficient. But in the mean time setting up a general infrastructure that uses the unique property of the one to one correspondence of the Laplace transform of inter-event times with the coalescent state space graph to efficiently iterate the associated mathematical expressions as well as evaluate them and propagate these results along the graph.


Here, we describe 
\begin{itemize}
\item an open-source implementation of the work that has been done, moving ... away from Mathematica \\
\item lay out how the key algorithms that have enabled us to efficiently calculate the bSFS by using the correspondence between the recursive formulation of the Laplace transform and the coalescent state space graph. %stress fact that although focus has been on bSFS, this correspondence can be used generally for any future type of calculation/evaluation of the associated equations.
\item implement the concept of equivalent mutation configuration enabling the calculating of bSFS for the fully labeled case.
%get back closer to the spirit of the coalescent and query the distribution of Laplace transformed coalescence times in a more efficient ways.
\end{itemize}

\section{Recursive description of the laplace transform}
%this section should make everything about the laplace transform clear such that it is obvious to understand in the next section what the equations look like, and what the dummy variables associated with branch types do and mean.
%describe coalescent slightly more here (all in 2Ne generations!)
Given a sample of $n$ uniquely labelled lineages $\Omega = \{a, ..., n\}$ coming from a single population, we can represent the state space of all (neutral) pairwise coalescence events as a rooted directed graph. As lineages coalesce we move through the graph from the source node, representing the sampled state, to the root or most recent common ancestor (mrca). Each node can be uniquely labelled by one of the partitions of $\Omega$. And the total number of paths through the graph will equal the number of ranked topologies: $n!(n-1)!/2^{n-1}$ \citep{Lohse2016} %there must be a better citation for this!   
For two lineages, Laplace transform is $\frac{1}{1+\omega}$ and we retrieve the probability of coalescence prior to a mutation happening by setting dummy variable omega to theta. Note that in general we will associate each ancestral branch type with a unique dummy variable such that we can retrieve the coalescence time distribution for each distinguished branch type. And given that the Laplace transform of the sum of random variables is equal to the product of their respective transforms, the recursive description for the distribution of coalescence times is:

 \begin{equation}\label{eq:recursion_neutral} 
 \begin{split}
         \Phi[\Omega] &:= \frac{1}{\binom{|\Omega|}{2}+ \sum\limits_{x \in \Omega}\omega_x} \cdot \sum\limits_{1 \leq i < j \leq |\Omega|} \Phi[\Omega_{i,j}]
 \end{split}
 \end{equation}
where the sum over $1 \leq i < j \leq |\Omega|$ represents the set of possible pair-wise coalescent events among the $\Omega$ lineages and the dummy variable terms $\omega_x$ are summed over all lineages $x$ present in $\Omega$. When $|\Omega|=1$, $\Phi[\Omega] = 1$ and the recursion ends.

Translating the recursion to traversing the graph, each edge leaving a particular node corresponds to a single Laplace transform (or a single factor in the recursion) with the dummy variables corresponding to the branchtypes building up the unique label of that particular node.

So far, dealt with coalescence, however, Laplace transform for any type of event with exponentially distributed waiting times will take the same form. We can even imagine wanting to describe scenarios where multiple types of these exponentially distributed events with rate $\lambda_k$ (migration, recombination, ...) are competing along the same branches.

 \begin{equation}\label{eq:recursion_all_events} 
 \begin{split}
         \Phi[\Omega] &:= \frac{\lambda_k}{\sum\limits_{k}\lambda_k+ \sum\limits_{x \in \Omega}\omega_x} \cdot \sum\limits_{k}\sum\limits_{1 \leq i < j \leq |\Omega|} \Phi[\Omega_{i,j}]
 \end{split}
 \end{equation}

adding events, translated in graph by their effect on the lineages.

%
Each single laplace transform takes the following form: LT: $f[\boldsymbol{\omega}] = \frac{c}{\sum c_i + \sum \omega_i}$ and can thus be encoded as a matrix with two rows, first row for numerator containing single non-zero value. Second row, denominator. Storing equations this way ensures we can efficiently substitute in parameter values (migration rate, ...) once the Laplace transform needs to be evaluated.

%Traversing the graph minimal representation of laplace transform, equation matrix and l
list of all paths.

%discrete events: discrete events like population splits or even the effect of a sweep can be encoded using the described recursion. These type of discrete events are initially treated as if happening as a commpeting exponential process at rate \delta. This means the recursion as described is remains general and all equations still take the described polymial form. However, the correct Laplace transform of c ,,,, requires taking the inverse Laplace with respect to \delta as described in \citep{Lohse2011, Bisschop2021}. Currently in agemo implemented ways of dealing with a single discrete event.

\section{branchtype mapping}
Section on how to simplify the coalescent state space.

\section{blockwise site frequency spectrum}

The blockwise site frequency spectrum or bSFS is the vector of site frequency spectrum counts in short blocks of a fixed length \citep{Bunnefeld2015}. It is the probability of seeing $k_i$ mutations on each of the $i$ distinguished branchtypes. 
For an unphased sample of size 3 the bSFS would be a vector of length $\{k_1, k_2\}$ with reprsenting the number $k_1$ being singletons, $k_2$ doubletons and $k_i \in \{0, 1, 2, k_{max} + 1\}$. Here, $k_{max}$ is used to bin all mutation configurations with more than $k_{max}$ mutations of type $i$. 
Deriving the probability for each of the $(k_max + 2)^c$, with $c$ the length of the bSFS vector, has thus far been the way in which the recursively generated Laplace transform of coalescence time distributions has been used. To determine the likelihood of observing particular blocks of data under the coalescent given a particular demographic model or sweep approximation \citep{Lohse2011, Bunnefeld2015, Lohse2016, Bisschop2021} and gIMble. Calculating these probabilities: probabilities correspond to $(-\theta/2)^{\sum k_s}$ times the coefficient of the corresponding term in a multivariate taylor series expansion of the generating function around $x_s=0$ after setting $\omega_s = theta/2 - x_s$ (see eq.\ (1) in \citet{Lohse2011} for details). Naive implementations of this approach, calculating derivaties using a computer alebra systems (CAS), suffer from an explosion in the number of terms due to the Leibniz or product rule when differentiating. On top of that, generally CAS fail to take into account the fact that the same partial derivatives will have to be computed multiple times. This problem has been well-studied for the purpose of automatic differentiation algorithms \citep{Neidinger1992, Neidinger1995, Griewank2000, Bettencourt2019}. One approach, implementing recurrence relations on how to combine truncated taylor series essentially building higher-order derivatives from the ground up by defining the series coefficients for the elementary functions and defining the recurrence relations for arithmetic operators as well as function compositions \citep{Neidinger2013}. Given that each laplace transform corresponding to a single path through the coalescent state space graph will consist of the product of factors of a fixed form (see previous section), we can use alg 3. (see alg. \ (8) in \citet{Neidinger2013}) to multiply once we have the series coefficients for each of these factors. This avoids having to recompute the same higher order diff over and over due to the product rule. On top of that, not a single but multiple paths through the coalescent state space graph. Here, we observe that two operations suffice to combine all series coefficients efficiently.
Evaluation order: from tmrca to root, evaluate which nodes depend on others.
%where do we add in the state space graph vs equation graph idea!?
After deriving evaluation order for the graph, a single pass through the graph, visiting all nodes exactly ones allow us to calculate the coefficients for the entire graph. seriesproduct for coefficient matrix of connected nodes, summing the coefficient matrices of all child nodes prior to multiplication.

Obviously, the more connected the coalescent state space graph, the more we will benefit from not implementing higher-order differentiation naively.
Because equations in our case all same shape, benefit from writing closed-form implementations of derivatives for the building blocks (equations). Not build from ground up.
%explain base case first

Following steps are needed:
%transform graph into equation graph making nodes for equations 
% associate each node with a coefficient matrix (alg. 1)
%propogate taylor series coefficients through graph (alg 3 and 4)

%add added layer of complexity: inverse laplace transform for discrete events. (alg. 2)

%% algorithms %%
\begin{algorithm}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}

    \underline{function diff_inverse_polynomial} $(denominator, variables, mutype, num_branchtypes)$\;
    \Input{}
    \Output{float $r$}
    total_diff_count = sum(diff_array);
    fact_diff = 1;
    \For{num in diff_array}{fact_diff *=num!;}
    fact = total_diff_count!/fact_diff;
    nomd = fact * denominator[-num_branchtypes:]^diff_array;
    \eIf{nomd==0.0}{return 0.0};
    denomd = dot_product^{total_diff_count + 1;}
    {return $(-1)^{total_diff_count}*nom/denomd$\;}
    \caption{Taylor series coefficient Laplace transform without discrete event}
\end{algorithm}

\begin{algorithm}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}

    \underline{function diff_inverse_polynomial} $(a, b)$\;
    \Input{Two arrays of floats $a$ and $b$}
    \Output{$c[ ]$}
    
    {return $c[ ]$\;}
    \caption{Taylor series coefficient Laplace transform with discrete event}
\end{algorithm}

%algorithm: from Neidinger
\begin{algorithm}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}

    \underline{function series\_product} $(a[ ],b[ ])$\;
    \Input{Two arrays of floats $a[ ]$ and $b[ ]$}
    \Output{$c[ ]$}
    \ForEach{multi-index $(\boldsymbol{k})$}{
        \ForEach{multi-index $\boldsymbol{j} \leq$ multi-index $\boldsymbol{k})$}{
            $sum = 0$\;
            $sum+= a[\boldsymbol{j}] * b[\boldsymbol{k}-\boldsymbol{j}]$\;
        }
        $c[\boldsymbol{k}]= sum$\;
        }
    {return $c[ ]$\;}
    \caption{Product of the coefficients of two truncated taylor series \citep{Neidinger2013}.}
\end{algorithm}

%algorithm: parsing graph using dependency list
\begin{algorithm}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}

    \underline{parse\_graph} (dependency\_list, graph, series\_coefficients)\;
    \Input{}
    \Output{$r[ ]$}
    node\_values = zeros((num\_nodes, *shape));
    \ForEach{parent in dependency\_list}{
        children = graph[parent];
        temp = instantiate_zero_array
        if children;
            \ForEach{child in children}{
                temp+=series\_coefficients[child];
                if parent!=0;
                    node_values[parent] = series\_product(temp, series\_coefficients[parent - 1]);
                else;
                    node_values[parent] = temp;
            }
        }
    {return $node\_values[0]$\;}
    \caption{Propagating taylor series through graph.}
\end{algorithm}

%%derivatives
%algorithm: inverse Laplace

%algorithm: derivatives polynomial

\section{Discussion}
%moving away from using a CAS sacrifices some degree of generality. Currently only possible to only incorporate a single discrete event with respect to which an inverse laplace can be calculated.

\section{Conclusions} 

\bibliography{../../Latex/Bibliography/library}
\bibliographystyle{apacite}
\end{document}